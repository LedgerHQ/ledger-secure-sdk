<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded SDK: Generic Linked List Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Embedded SDK
   </div>
   <div id="projectbrief">Embedded SDK</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Embedded SDK</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Generic Linked List Library</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="list_mainpage_intro"></a>
Introduction</h1>
<p>This page describes the Generic Linked List library available for Applications.</p>
<p>The <code>lib_lists</code> provides two types of linked list implementations:</p><ul>
<li><b>Forward lists</b> (<code>flist_*</code>): Singly-linked lists with minimal memory overhead</li>
<li><b>Doubly-linked lists</b> (<code>list_*</code>): Bidirectional lists with previous pointers</li>
</ul>
<p>Both implementations share a common architecture with generic node structures that can be embedded in any data structure. This design is based on the app-ethereum implementation and is optimized for embedded systems like Ledger devices.</p>
<h1><a class="anchor" id="list_node_structure"></a>
Node Structures</h1>
<h2><a class="anchor" id="flist_node"></a>
Forward List Node (Singly-Linked)</h2>
<p>The forward list node contains only a next pointer:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> {</div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>;</div>
<div class="line">} <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a>;</div>
<div class="ttc" id="astructflist__node__t_html"><div class="ttname"><a href="structflist__node__t.html">flist_node_t</a></div><div class="ttdoc">Forward list node structure (singly-linked)</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00024">lists.h:24</a></div></div>
<div class="ttc" id="astructflist__node__t_html_a0d6e55dc76b1ae818db2f628b6f1cec6"><div class="ttname"><a href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">flist_node_t::next</a></div><div class="ttdeci">struct flist_node_t * next</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00025">lists.h:25</a></div></div>
</div><!-- fragment --><p>Usage:** Embed <code><a class="el" href="structflist__node__t.html" title="Forward list node structure (singly-linked)">flist_node_t</a></code> as the first member of your structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>my_data_s {</div>
<div class="line">    <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> node;  <span class="comment">// Must be first member</span></div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <span class="keywordtype">char</span> name[32];</div>
<div class="line">} my_data_t;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *my_flist = NULL;  <span class="comment">// Empty forward list</span></div>
</div><!-- fragment --><p>Memory overhead:** 4-8 bytes per node (one pointer)</p>
<h2><a class="anchor" id="list_node"></a>
Doubly-Linked List Node</h2>
<p>The doubly-linked node contains both next and previous pointers:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> {</div>
<div class="line">    <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a>        <a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>;  <span class="comment">// Contains next pointer</span></div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *<a class="code hl_variable" href="structlist__node__t.html#a77501f97ec2ef65d96e5282b03720389">prev</a>;   <span class="comment">// Previous pointer</span></div>
<div class="line">} <a class="code hl_struct" href="structlist__node__t.html">list_node_t</a>;</div>
<div class="ttc" id="astructlist__node__t_html"><div class="ttname"><a href="structlist__node__t.html">list_node_t</a></div><div class="ttdoc">Doubly-linked list node structure.</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00039">lists.h:39</a></div></div>
<div class="ttc" id="astructlist__node__t_html_a364ec28eec122d63d3999b85fbec858a"><div class="ttname"><a href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">list_node_t::_list</a></div><div class="ttdeci">flist_node_t _list</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00040">lists.h:40</a></div></div>
<div class="ttc" id="astructlist__node__t_html_a77501f97ec2ef65d96e5282b03720389"><div class="ttname"><a href="structlist__node__t.html#a77501f97ec2ef65d96e5282b03720389">list_node_t::prev</a></div><div class="ttdeci">struct list_node_t * prev</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00041">lists.h:41</a></div></div>
</div><!-- fragment --><p>Usage:** Embed <code><a class="el" href="structlist__node__t.html" title="Doubly-linked list node structure.">list_node_t</a></code> as the first member of your structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>my_data_s {</div>
<div class="line">    <a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> node;  <span class="comment">// Must be first member</span></div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line">    <span class="keywordtype">char</span> name[32];</div>
<div class="line">} my_data_t;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *my_list = NULL;  <span class="comment">// Empty doubly-linked list</span></div>
</div><!-- fragment --><p>Memory overhead:** 8-16 bytes per node (two pointers)</p>
<h2><a class="anchor" id="list_choosing"></a>
Choosing Between Forward Lists and Doubly-Linked Lists</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone">Forward List (<code>flist</code>)   </th><th class="markdownTableHeadNone">Doubly-Linked (<code>list</code>)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory per node   </td><td class="markdownTableBodyNone">4-8 bytes   </td><td class="markdownTableBodyNone">8-16 bytes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Insert/remove at front   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Insert/remove at back   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(1) ⚡    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Insert after node   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Insert before node   </td><td class="markdownTableBodyNone">Not available   </td><td class="markdownTableBodyNone">O(1) ⚡    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Backward traversal   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">Yes ⚡    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Reverse operation   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td></tr>
</table>
<p>Best practice:** Use forward lists when memory is critical and you don't need backward traversal or frequent tail operations. Use doubly-linked lists when you need bidirectional access or O(1) tail operations.</p>
<h1><a class="anchor" id="list_complexity"></a>
Understanding Time Complexity</h1>
<p>The documentation uses <b>Big O notation</b> to describe algorithm performance:</p>
<ul>
<li><b>O(1) - Constant time</b>: The operation takes the same time regardless of list size<ul>
<li>Example: Adding to the front of the list always requires the same steps</li>
<li>Performance: Excellent for embedded systems ✓</li>
</ul>
</li>
<li><b>O(n) - Linear time</b>: Time increases proportionally with the number of elements (n)<ul>
<li>Example: Finding the last element requires traversing all n elements</li>
<li>Performance: Acceptable for small to medium lists</li>
</ul>
</li>
<li><p class="startli"><b>O(n²) - Quadratic time</b>: Time increases with the square of the number of elements</p><ul>
<li>Example: Bubble sort compares elements multiple times</li>
<li>Performance: Avoid for large lists in embedded systems</li>
</ul>
<p class="startli">Concrete examples:** </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">List Size   </th><th class="markdownTableHeadNone">O(1)   </th><th class="markdownTableHeadNone">O(n)   </th><th class="markdownTableHeadNone">O(n²)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10 items   </td><td class="markdownTableBodyNone">1 step   </td><td class="markdownTableBodyNone">10 steps   </td><td class="markdownTableBodyNone">100 steps    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100 items   </td><td class="markdownTableBodyNone">1 step   </td><td class="markdownTableBodyNone">100 steps   </td><td class="markdownTableBodyNone">10,000 steps    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000 items   </td><td class="markdownTableBodyNone">1 step   </td><td class="markdownTableBodyNone">1,000 steps   </td><td class="markdownTableBodyNone">1,000,000 steps   </td></tr>
</table>
<p class="startli">Best practice:** Always prefer O(1) operations when possible for optimal performance.</p>
</li>
</ul>
<h1><a class="anchor" id="list_operations"></a>
Basic Operations</h1>
<p>All operations are available for both forward lists and doubly-linked lists with similar APIs:</p><ul>
<li>Forward list functions: <code>flist_*</code></li>
<li>Doubly-linked list functions: <code>list_*</code></li>
</ul>
<p>All mutating functions return <code>bool</code> to indicate success or failure.</p>
<h2><a class="anchor" id="list_insertion"></a>
Insertion Operations</h2>
<p>Push Front** - Add a node at the beginning (O(1) for both types):</p>
<div class="fragment"><div class="line"><span class="comment">// Forward list example</span></div>
<div class="line">my_data_t *data = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data-&gt;node.next = NULL;  <span class="comment">// Must be NULL before insertion</span></div>
<div class="line">data-&gt;value = 42;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#ad0fdc2f8fa8e240cca81e7841b743992">flist_push_front</a>(&amp;my_flist, &amp;data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked list example</span></div>
<div class="line">my_data_t *data2 = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data2-&gt;node._list.next = NULL;</div>
<div class="line">data2-&gt;node.prev = NULL;  <span class="comment">// Both pointers must be NULL</span></div>
<div class="line">data2-&gt;value = 43;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#acd04c3335f45306b50822d5a3a98724e">list_push_front</a>(&amp;my_list, &amp;data2-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_acd04c3335f45306b50822d5a3a98724e"><div class="ttname"><a href="lists_8c.html#acd04c3335f45306b50822d5a3a98724e">list_push_front</a></div><div class="ttdeci">bool list_push_front(list_node_t **list, list_node_t *node)</div><div class="ttdoc">Add a node at the beginning of the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00348">lists.c:348</a></div></div>
<div class="ttc" id="alists_8c_html_ad0fdc2f8fa8e240cca81e7841b743992"><div class="ttname"><a href="lists_8c.html#ad0fdc2f8fa8e240cca81e7841b743992">flist_push_front</a></div><div class="ttdeci">bool flist_push_front(flist_node_t **list, flist_node_t *node)</div><div class="ttdoc">Add a node at the beginning of the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00239">lists.c:239</a></div></div>
</div><!-- fragment --><p>Push Back** - Add a node at the end:</p><ul>
<li>Forward list: O(n) - must traverse entire list</li>
<li>Doubly-linked: O(1) - direct access via prev pointer ⚡</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Forward list: O(n)</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a38398579519ac57a386a176966a98826">flist_push_back</a>(&amp;my_flist, &amp;data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked: O(1) - faster!</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a15bf5be737b19961239322ad8aa091c8">list_push_back</a>(&amp;my_list, &amp;data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a15bf5be737b19961239322ad8aa091c8"><div class="ttname"><a href="lists_8c.html#a15bf5be737b19961239322ad8aa091c8">list_push_back</a></div><div class="ttdeci">bool list_push_back(list_node_t **list, list_node_t *node)</div><div class="ttdoc">Add a node at the end of the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00358">lists.c:358</a></div></div>
<div class="ttc" id="alists_8c_html_a38398579519ac57a386a176966a98826"><div class="ttname"><a href="lists_8c.html#a38398579519ac57a386a176966a98826">flist_push_back</a></div><div class="ttdeci">bool flist_push_back(flist_node_t **list, flist_node_t *node)</div><div class="ttdoc">Add a node at the end of the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00249">lists.c:249</a></div></div>
</div><!-- fragment --><p>Insert After** - Insert a node after a reference node (O(1) for both):</p>
<div class="fragment"><div class="line">my_data_t *new_data = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">new_data-&gt;node._list.next = NULL;</div>
<div class="line">new_data-&gt;node.prev = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#af9f27d289a5ed11596b0940c1716e0c6">list_insert_after</a>(&amp;my_list, &amp;ref_node, &amp;new_data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted after ref_node</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_af9f27d289a5ed11596b0940c1716e0c6"><div class="ttname"><a href="lists_8c.html#af9f27d289a5ed11596b0940c1716e0c6">list_insert_after</a></div><div class="ttdeci">bool list_insert_after(list_node_t **list, list_node_t *ref, list_node_t *node)</div><div class="ttdoc">Insert a node after a reference node in the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00382">lists.c:382</a></div></div>
</div><!-- fragment --><p>Insert Before** - Insert a node before a reference node:</p><ul>
<li>Forward list: Not available (requires backward traversal)</li>
<li>Doubly-linked: O(1) - direct access via prev pointer ⚡</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Only available for doubly-linked lists</span></div>
<div class="line">my_data_t *new_data = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">new_data-&gt;node._list.next = NULL;</div>
<div class="line">new_data-&gt;node.prev = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#aa412ac0988d3ffd355d55787036c16a3">list_insert_before</a>(&amp;my_list, &amp;ref_node, &amp;new_data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Successfully inserted before ref_node</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_aa412ac0988d3ffd355d55787036c16a3"><div class="ttname"><a href="lists_8c.html#aa412ac0988d3ffd355d55787036c16a3">list_insert_before</a></div><div class="ttdeci">bool list_insert_before(list_node_t **list, list_node_t *ref, list_node_t *node)</div><div class="ttdoc">Insert a node before a reference node in the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00368">lists.c:368</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="list_removal"></a>
Removal Operations</h2>
<p>All removal functions return <code>bool</code> to indicate success or failure (except <code>remove_if</code>). They accept an optional deletion callback to clean up node data.</p>
<p>Pop Front** - Remove the first node (O(1) for both):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_delete_func(<a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node) {</div>
<div class="line">    my_data_t *data = (my_data_t *)node;</div>
<div class="line">    <span class="comment">// Clean up data if needed</span></div>
<div class="line">    free(data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a3e4aaca4385909077a0d841a5e0c1eca">flist_pop_front</a>(&amp;my_flist, my_delete_func)) {</div>
<div class="line">    <span class="comment">// First node was removed and freed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a74ef4a5c4915f09294b2e6dacfeaff9f">list_pop_front</a>(&amp;my_list, (<a class="code hl_typedef" href="lists_8h.html#ae59cc7c9ebd4587f533a9ea55b1ae9f7">f_list_node_del</a>)my_delete_func)) {</div>
<div class="line">    <span class="comment">// First node was removed and freed</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a3e4aaca4385909077a0d841a5e0c1eca"><div class="ttname"><a href="lists_8c.html#a3e4aaca4385909077a0d841a5e0c1eca">flist_pop_front</a></div><div class="ttdeci">bool flist_pop_front(flist_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete the first node from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00244">lists.c:244</a></div></div>
<div class="ttc" id="alists_8c_html_a74ef4a5c4915f09294b2e6dacfeaff9f"><div class="ttname"><a href="lists_8c.html#a74ef4a5c4915f09294b2e6dacfeaff9f">list_pop_front</a></div><div class="ttdeci">bool list_pop_front(list_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete the first node from the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00353">lists.c:353</a></div></div>
<div class="ttc" id="alists_8h_html_ae59cc7c9ebd4587f533a9ea55b1ae9f7"><div class="ttname"><a href="lists_8h.html#ae59cc7c9ebd4587f533a9ea55b1ae9f7">f_list_node_del</a></div><div class="ttdeci">void(* f_list_node_del)(flist_node_t *node)</div><div class="ttdoc">Callback function to delete/free a node.</div><div class="ttdef"><b>Definition</b> <a href="lists_8h_source.html#l00056">lists.h:56</a></div></div>
</div><!-- fragment --><p>Pop Back** - Remove the last node:</p><ul>
<li>Forward list: O(n) - must find second-to-last node</li>
<li>Doubly-linked: O(1) - direct access via prev pointer ⚡</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Forward list: O(n)</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#aeb86a2bf6182328341b1b6a79901b99d">flist_pop_back</a>(&amp;my_flist, my_delete_func)) {</div>
<div class="line">    <span class="comment">// Last node was removed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked: O(1) - faster!</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a7af18a113995665ffec5a1e0b8d8c13f">list_pop_back</a>(&amp;my_list, (<a class="code hl_typedef" href="lists_8h.html#ae59cc7c9ebd4587f533a9ea55b1ae9f7">f_list_node_del</a>)my_delete_func)) {</div>
<div class="line">    <span class="comment">// Last node was removed</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a7af18a113995665ffec5a1e0b8d8c13f"><div class="ttname"><a href="lists_8c.html#a7af18a113995665ffec5a1e0b8d8c13f">list_pop_back</a></div><div class="ttdeci">bool list_pop_back(list_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete the last node from the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00363">lists.c:363</a></div></div>
<div class="ttc" id="alists_8c_html_aeb86a2bf6182328341b1b6a79901b99d"><div class="ttname"><a href="lists_8c.html#aeb86a2bf6182328341b1b6a79901b99d">flist_pop_back</a></div><div class="ttdeci">bool flist_pop_back(flist_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete the last node from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00254">lists.c:254</a></div></div>
</div><!-- fragment --><p>Remove** - Remove a specific node (O(n) for forward, O(1) for doubly-linked):</p>
<div class="fragment"><div class="line"><span class="comment">// Forward list: O(n) - must find previous node</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a8ffa41bc7183d211b6f1664c1ad4b518">flist_remove</a>(&amp;my_flist, &amp;node_to_remove, my_delete_func)) {</div>
<div class="line">    <span class="comment">// Node was found and removed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked: O(1) - direct access via prev pointer ⚡</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a2b9cf05d8e1e23402568f0cc7e0f695d">list_remove</a>(&amp;my_list, &amp;node_to_remove, (<a class="code hl_typedef" href="lists_8h.html#ae59cc7c9ebd4587f533a9ea55b1ae9f7">f_list_node_del</a>)my_delete_func)) {</div>
<div class="line">    <span class="comment">// Node was removed instantly</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a2b9cf05d8e1e23402568f0cc7e0f695d"><div class="ttname"><a href="lists_8c.html#a2b9cf05d8e1e23402568f0cc7e0f695d">list_remove</a></div><div class="ttdeci">bool list_remove(list_node_t **list, list_node_t *node, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete a specific node from the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00388">lists.c:388</a></div></div>
<div class="ttc" id="alists_8c_html_a8ffa41bc7183d211b6f1664c1ad4b518"><div class="ttname"><a href="lists_8c.html#a8ffa41bc7183d211b6f1664c1ad4b518">flist_remove</a></div><div class="ttdeci">bool flist_remove(flist_node_t **list, flist_node_t *node, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete a specific node from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00282">lists.c:282</a></div></div>
</div><!-- fragment --><p>Remove If** - Remove all nodes matching a predicate (O(n) for both):</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_negative(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node) {</div>
<div class="line">    <span class="keyword">const</span> my_data_t *data = (<span class="keyword">const</span> my_data_t *)node;</div>
<div class="line">    <span class="keywordflow">return</span> data-&gt;value &lt; 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns the number of removed nodes</span></div>
<div class="line"><span class="keywordtype">size_t</span> removed = <a class="code hl_function" href="lists_8c.html#a325ba8b8be1eb8ccc080d3b1d5c79e8f">flist_remove_if</a>(&amp;my_flist, is_negative, my_delete_func);</div>
<div class="line">printf(<span class="stringliteral">&quot;Removed %zu negative values\n&quot;</span>, removed);</div>
<div class="ttc" id="alists_8c_html_a325ba8b8be1eb8ccc080d3b1d5c79e8f"><div class="ttname"><a href="lists_8c.html#a325ba8b8be1eb8ccc080d3b1d5c79e8f">flist_remove_if</a></div><div class="ttdeci">size_t flist_remove_if(flist_node_t **list, f_list_node_pred pred_func, f_list_node_del del_func)</div><div class="ttdoc">Remove all nodes matching a predicate from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00287">lists.c:287</a></div></div>
</div><!-- fragment --><p>Clear** - Remove all nodes (O(n) for both):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#ada7cc33a718ce99dc5f2118068a992b2">flist_clear</a>(&amp;my_flist, my_delete_func)) {</div>
<div class="line">    <span class="comment">// All nodes were removed and list is now empty</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_ada7cc33a718ce99dc5f2118068a992b2"><div class="ttname"><a href="lists_8c.html#ada7cc33a718ce99dc5f2118068a992b2">flist_clear</a></div><div class="ttdeci">bool flist_clear(flist_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete all nodes from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00292">lists.c:292</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="list_utilities"></a>
Utility Operations</h2>
<p>Get Size** - Count the number of nodes (O(n) for both):</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> count = <a class="code hl_function" href="lists_8c.html#a62856e2deaffb69dc16d7d1fa43f8b85">flist_size</a>(&amp;my_flist);</div>
<div class="line"><span class="keywordtype">size_t</span> count2 = <a class="code hl_function" href="lists_8c.html#a9bc393cf60a54f41b0b6f2fd177cd0f4">list_size</a>(&amp;my_list);</div>
<div class="ttc" id="alists_8c_html_a62856e2deaffb69dc16d7d1fa43f8b85"><div class="ttname"><a href="lists_8c.html#a62856e2deaffb69dc16d7d1fa43f8b85">flist_size</a></div><div class="ttdeci">size_t flist_size(flist_node_t *const *list)</div><div class="ttdoc">Get the number of nodes in the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00312">lists.c:312</a></div></div>
<div class="ttc" id="alists_8c_html_a9bc393cf60a54f41b0b6f2fd177cd0f4"><div class="ttname"><a href="lists_8c.html#a9bc393cf60a54f41b0b6f2fd177cd0f4">list_size</a></div><div class="ttdeci">size_t list_size(list_node_t *const *list)</div><div class="ttdoc">Get the number of nodes in the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00403">lists.c:403</a></div></div>
</div><!-- fragment --><p>Check Empty** - Test if list is empty (O(1) for both):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#ab76a2daec83164cd090c5b8ec7330b8d">flist_empty</a>(&amp;my_flist)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Forward list is empty\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a83bf372b80a839f2f82d0bf671506e96">list_empty</a>(&amp;my_list)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Doubly-linked list is empty\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a83bf372b80a839f2f82d0bf671506e96"><div class="ttname"><a href="lists_8c.html#a83bf372b80a839f2f82d0bf671506e96">list_empty</a></div><div class="ttdeci">bool list_empty(list_node_t *const *list)</div><div class="ttdoc">Check if the doubly-linked list is empty.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00408">lists.c:408</a></div></div>
<div class="ttc" id="alists_8c_html_ab76a2daec83164cd090c5b8ec7330b8d"><div class="ttname"><a href="lists_8c.html#ab76a2daec83164cd090c5b8ec7330b8d">flist_empty</a></div><div class="ttdeci">bool flist_empty(flist_node_t *const *list)</div><div class="ttdoc">Check if the forward list is empty.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00324">lists.c:324</a></div></div>
</div><!-- fragment --><p>Sort** - Sort the list using a comparison function (O(n²) for both):</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> my_compare_func(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *a, <span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *b) {</div>
<div class="line">    my_data_t *data_a = (my_data_t *)a;</div>
<div class="line">    my_data_t *data_b = (my_data_t *)b;</div>
<div class="line">    <span class="keywordflow">return</span> data_a-&gt;value &lt;= data_b-&gt;value;  <span class="comment">// true if in correct order</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a1d2ef5df3acb9c143b11dedbf8f98873">flist_sort</a>(&amp;my_flist, my_compare_func)) {</div>
<div class="line">    <span class="comment">// List is now sorted</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a719b2029d34584edd0f865f23db61d23">list_sort</a>(&amp;my_list, my_compare_func)) {</div>
<div class="line">    <span class="comment">// List is now sorted</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a1d2ef5df3acb9c143b11dedbf8f98873"><div class="ttname"><a href="lists_8c.html#a1d2ef5df3acb9c143b11dedbf8f98873">flist_sort</a></div><div class="ttdeci">bool flist_sort(flist_node_t **list, f_list_node_cmp cmp_func)</div><div class="ttdoc">Sort the forward list using a comparison function.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00329">lists.c:329</a></div></div>
<div class="ttc" id="alists_8c_html_a719b2029d34584edd0f865f23db61d23"><div class="ttname"><a href="lists_8c.html#a719b2029d34584edd0f865f23db61d23">list_sort</a></div><div class="ttdeci">bool list_sort(list_node_t **list, f_list_node_cmp cmp_func)</div><div class="ttdoc">Sort the doubly-linked list using a comparison function.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00413">lists.c:413</a></div></div>
</div><!-- fragment --><p>Unique** - Remove consecutive duplicate nodes (O(n) for both):</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> are_equal(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *a, <span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *b) {</div>
<div class="line">    <span class="keyword">const</span> my_data_t *data_a = (<span class="keyword">const</span> my_data_t *)a;</div>
<div class="line">    <span class="keyword">const</span> my_data_t *data_b = (<span class="keyword">const</span> my_data_t *)b;</div>
<div class="line">    <span class="keywordflow">return</span> data_a-&gt;value == data_b-&gt;value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns the number of removed duplicates</span></div>
<div class="line"><span class="keywordtype">size_t</span> removed = <a class="code hl_function" href="lists_8c.html#ab0fdc9ebd75e23b44aba0bdee29abc73">flist_unique</a>(&amp;my_flist, are_equal, my_delete_func);</div>
<div class="line">printf(<span class="stringliteral">&quot;Removed %zu duplicates\n&quot;</span>, removed);</div>
<div class="ttc" id="alists_8c_html_ab0fdc9ebd75e23b44aba0bdee29abc73"><div class="ttname"><a href="lists_8c.html#ab0fdc9ebd75e23b44aba0bdee29abc73">flist_unique</a></div><div class="ttdeci">size_t flist_unique(flist_node_t **list, f_list_node_bin_pred pred_func, f_list_node_del del_func)</div><div class="ttdoc">Remove consecutive duplicate nodes from the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00334">lists.c:334</a></div></div>
</div><!-- fragment --><p>Reverse** - Reverse the order of nodes (O(n) for both):</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a27afe8b13878e2178d62ab4b3f842f78">flist_reverse</a>(&amp;my_flist)) {</div>
<div class="line">    <span class="comment">// List is now reversed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#abf9c6b10f59eadb0df659dc91b1a9b9c">list_reverse</a>(&amp;my_list)) {</div>
<div class="line">    <span class="comment">// List is now reversed</span></div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a27afe8b13878e2178d62ab4b3f842f78"><div class="ttname"><a href="lists_8c.html#a27afe8b13878e2178d62ab4b3f842f78">flist_reverse</a></div><div class="ttdeci">bool flist_reverse(flist_node_t **list)</div><div class="ttdoc">Reverse the order of nodes in the forward list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00339">lists.c:339</a></div></div>
<div class="ttc" id="alists_8c_html_abf9c6b10f59eadb0df659dc91b1a9b9c"><div class="ttname"><a href="lists_8c.html#abf9c6b10f59eadb0df659dc91b1a9b9c">list_reverse</a></div><div class="ttdeci">bool list_reverse(list_node_t **list)</div><div class="ttdoc">Reverse the order of nodes in the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00423">lists.c:423</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="list_traversal"></a>
List Traversal</h1>
<h2><a class="anchor" id="flist_traversal"></a>
Forward List Traversal (Forward Only)</h2>
<div class="fragment"><div class="line"><span class="comment">// Forward iteration only</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node = my_flist; node != NULL; node = node-&gt;<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>) {</div>
<div class="line">    my_data_t *data = (my_data_t *)node;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, data-&gt;value);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="list_traversal"></a>
List Traversal</h2>
<div class="fragment"><div class="line"><span class="comment">// Forward iteration</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *node = my_list; node != NULL; node = (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *)node-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>) {</div>
<div class="line">    my_data_t *data = (my_data_t *)node;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, data-&gt;value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Backward iteration - only possible with doubly-linked lists!</span></div>
<div class="line"><a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *tail = my_list;</div>
<div class="line"><span class="keywordflow">if</span> (tail != NULL) {</div>
<div class="line">    <span class="comment">// Find the tail</span></div>
<div class="line">    <span class="keywordflow">while</span> (tail-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a> != NULL) {</div>
<div class="line">        tail = (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *)tail-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Traverse backward</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *node = tail; node != NULL; node = node-&gt;<a class="code hl_variable" href="structlist__node__t.html#a77501f97ec2ef65d96e5282b03720389">prev</a>) {</div>
<div class="line">        my_data_t *data = (my_data_t *)node;</div>
<div class="line">        printf(<span class="stringliteral">&quot;Value: %d\n&quot;</span>, data-&gt;value);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="list_safety"></a>
Safety and Error Handling</h1>
<p>The library implements several safety checks:</p>
<ol type="1">
<li><b>NULL pointer checks</b>: All functions validate their parameters</li>
<li><b>Node state validation</b>:<ul>
<li>Forward list: Insertion functions verify that <code>node-&gt;next == NULL</code></li>
<li>Doubly-linked: Insertion functions verify that both <code>node-&gt;_list.next</code> and <code>node-&gt;prev</code> are NULL</li>
<li>This prevents:<ul>
<li>Creating cycles in the list</li>
<li>Accidentally linking nodes from different lists</li>
<li>Losing track of existing node chains</li>
</ul>
</li>
</ul>
</li>
<li><b>Return value checking</b>: All mutating operations return <code>bool</code>:<ul>
<li><code>true</code>: Operation succeeded</li>
<li><code>false</code>: Invalid parameters or operation failed (e.g., node not found)</li>
</ul>
</li>
<li><p class="startli"><b>Counter operations</b>: <code>remove_if</code>, <code>unique</code>, and <code>size</code> return <code>size_t</code> with count information</p>
<p class="startli">Common error scenarios:**</p>
</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Forward list error</span></div>
<div class="line">my_data_t *data = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data-&gt;node.next = some_other_node;  <span class="comment">// Already linked!</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="lists_8c.html#ad0fdc2f8fa8e240cca81e7841b743992">flist_push_front</a>(&amp;my_flist, &amp;data-&gt;node)) {</div>
<div class="line">    <span class="comment">// ERROR: node-&gt;next was not NULL</span></div>
<div class="line">    <span class="comment">// This prevents accidentally breaking another list</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked list error</span></div>
<div class="line">my_data_t *data2 = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data2-&gt;node.prev = some_node;  <span class="comment">// Already linked!</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="lists_8c.html#acd04c3335f45306b50822d5a3a98724e">list_push_front</a>(&amp;my_list, &amp;data2-&gt;node)) {</div>
<div class="line">    <span class="comment">// ERROR: node-&gt;prev was not NULL</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="list_best_practices"></a>
Best Practices</h1>
<ol type="1">
<li><b>Always initialize node pointers to NULL</b> before insertion: <div class="fragment"><div class="line"><span class="comment">// Forward list</span></div>
<div class="line">my_data_t *data = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data-&gt;node.next = NULL;  <span class="comment">// Critical!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doubly-linked list</span></div>
<div class="line">my_data_t *data2 = malloc(<span class="keyword">sizeof</span>(my_data_t));</div>
<div class="line">data2-&gt;node._list.next = NULL;  <span class="comment">// Critical!</span></div>
<div class="line">data2-&gt;node.prev = NULL;        <span class="comment">// Critical!</span></div>
</div><!-- fragment --></li>
<li><b>Check return values</b> to detect errors: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="lists_8c.html#ad0fdc2f8fa8e240cca81e7841b743992">flist_push_front</a>(&amp;my_flist, &amp;data-&gt;node)) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Use the deletion callback</b> to prevent memory leaks: <div class="fragment"><div class="line"><a class="code hl_function" href="lists_8c.html#ada7cc33a718ce99dc5f2118068a992b2">flist_clear</a>(&amp;my_flist, my_delete_func);</div>
</div><!-- fragment --></li>
<li><b>Choose the right list type:</b><ul>
<li>Use <code>flist</code> (forward list) for minimal memory usage</li>
<li>Use <code>list</code> (doubly-linked) for bidirectional access or frequent tail operations</li>
</ul>
</li>
<li><b>Prefer front operations</b> when order doesn't matter:<ul>
<li><code>flist_push_front</code> is O(1)</li>
<li><code>list_push_front</code> is O(1)</li>
<li>Both are faster than push_back for forward lists</li>
</ul>
</li>
<li><b>Don't reuse nodes</b> across multiple lists without proper unlinking</li>
</ol>
<h1><a class="anchor" id="list_examples"></a>
Complete Examples</h1>
<h2><a class="anchor" id="list_example_basic"></a>
Forward List Basic Usage</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="lists_8h.html">lists.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>person_s {</div>
<div class="line">    <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> node;</div>
<div class="line">    <span class="keywordtype">char</span> name[32];</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">} person_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> delete_person(<a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node) {</div>
<div class="line">    person_t *person = (person_t *)node;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Deleting: %s\n&quot;</span>, person-&gt;name);</div>
<div class="line">    free(person);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *people = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add some people</span></div>
<div class="line">    person_t *alice = malloc(<span class="keyword">sizeof</span>(person_t));</div>
<div class="line">    alice-&gt;node.next = NULL;</div>
<div class="line">    strcpy(alice-&gt;name, <span class="stringliteral">&quot;Alice&quot;</span>);</div>
<div class="line">    alice-&gt;age = 30;</div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#ad0fdc2f8fa8e240cca81e7841b743992">flist_push_front</a>(&amp;people, &amp;alice-&gt;node);</div>
<div class="line"> </div>
<div class="line">    person_t *bob = malloc(<span class="keyword">sizeof</span>(person_t));</div>
<div class="line">    bob-&gt;node.next = NULL;</div>
<div class="line">    strcpy(bob-&gt;name, <span class="stringliteral">&quot;Bob&quot;</span>);</div>
<div class="line">    bob-&gt;age = 25;</div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#a38398579519ac57a386a176966a98826">flist_push_back</a>(&amp;people, &amp;bob-&gt;node);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print all people</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node = people; node != NULL; node = node-&gt;<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>) {</div>
<div class="line">        person_t *p = (person_t *)node;</div>
<div class="line">        printf(<span class="stringliteral">&quot;%s is %d years old\n&quot;</span>, p-&gt;name, p-&gt;age);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Clean up</span></div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#ada7cc33a718ce99dc5f2118068a992b2">flist_clear</a>(&amp;people, delete_person);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alists_8h_html"><div class="ttname"><a href="lists_8h.html">lists.h</a></div><div class="ttdoc">Generic linked list implementation (singly and doubly-linked)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="list_example_doubly"></a>
Doubly-Linked List with Backward Traversal</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="lists_8h.html">lists.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>person_s {</div>
<div class="line">    <a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> node;</div>
<div class="line">    <span class="keywordtype">char</span> name[32];</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">} person_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> delete_person_dl(<a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node) {</div>
<div class="line">    person_t *person = (person_t *)node;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Deleting: %s\n&quot;</span>, person-&gt;name);</div>
<div class="line">    free(person);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">    <a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *people = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add people (O(1) for both front and back!)</span></div>
<div class="line">    person_t *alice = malloc(<span class="keyword">sizeof</span>(person_t));</div>
<div class="line">    alice-&gt;node._list.next = NULL;</div>
<div class="line">    alice-&gt;node.prev = NULL;</div>
<div class="line">    strcpy(alice-&gt;name, <span class="stringliteral">&quot;Alice&quot;</span>);</div>
<div class="line">    alice-&gt;age = 30;</div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#a15bf5be737b19961239322ad8aa091c8">list_push_back</a>(&amp;people, &amp;alice-&gt;node);  <span class="comment">// O(1) - fast!</span></div>
<div class="line"> </div>
<div class="line">    person_t *bob = malloc(<span class="keyword">sizeof</span>(person_t));</div>
<div class="line">    bob-&gt;node._list.next = NULL;</div>
<div class="line">    bob-&gt;node.prev = NULL;</div>
<div class="line">    strcpy(bob-&gt;name, <span class="stringliteral">&quot;Bob&quot;</span>);</div>
<div class="line">    bob-&gt;age = 25;</div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#a15bf5be737b19961239322ad8aa091c8">list_push_back</a>(&amp;people, &amp;bob-&gt;node);  <span class="comment">// O(1) - fast!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Forward traversal</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Forward:\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *node = people; node != NULL; node = (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *)node-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>) {</div>
<div class="line">        person_t *p = (person_t *)node;</div>
<div class="line">        printf(<span class="stringliteral">&quot;  %s is %d years old\n&quot;</span>, p-&gt;name, p-&gt;age);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Backward traversal - only possible with doubly-linked!</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Backward:\n&quot;</span>);</div>
<div class="line">    <a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *tail = people;</div>
<div class="line">    <span class="keywordflow">while</span> (tail &amp;&amp; tail-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>) {</div>
<div class="line">        tail = (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *)tail-&gt;<a class="code hl_variable" href="structlist__node__t.html#a364ec28eec122d63d3999b85fbec858a">_list</a>.<a class="code hl_variable" href="structflist__node__t.html#a0d6e55dc76b1ae818db2f628b6f1cec6">next</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_struct" href="structlist__node__t.html">list_node_t</a> *node = tail; node != NULL; node = node-&gt;<a class="code hl_variable" href="structlist__node__t.html#a77501f97ec2ef65d96e5282b03720389">prev</a>) {</div>
<div class="line">        person_t *p = (person_t *)node;</div>
<div class="line">        printf(<span class="stringliteral">&quot;  %s is %d years old\n&quot;</span>, p-&gt;name, p-&gt;age);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Clean up</span></div>
<div class="line">    <a class="code hl_function" href="lists_8c.html#a702dd191d75d253f778270f63542c50e">list_clear</a>(&amp;people, delete_person_dl);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alists_8c_html_a702dd191d75d253f778270f63542c50e"><div class="ttname"><a href="lists_8c.html#a702dd191d75d253f778270f63542c50e">list_clear</a></div><div class="ttdeci">bool list_clear(list_node_t **list, f_list_node_del del_func)</div><div class="ttdoc">Remove and delete all nodes from the doubly-linked list.</div><div class="ttdef"><b>Definition</b> <a href="lists_8c_source.html#l00398">lists.c:398</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="list_example_sort"></a>
Sorting Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> compare_age(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *a, <span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *b) {</div>
<div class="line">    <span class="keyword">const</span> person_t *pa = (<span class="keyword">const</span> person_t *)a;</div>
<div class="line">    <span class="keyword">const</span> person_t *pb = (<span class="keyword">const</span> person_t *)b;</div>
<div class="line">    <span class="keywordflow">return</span> pa-&gt;age &lt;= pb-&gt;age;  <span class="comment">// Sort by age ascending</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sort forward list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a1d2ef5df3acb9c143b11dedbf8f98873">flist_sort</a>(&amp;people, compare_age)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Forward list sorted by age\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sort doubly-linked list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a719b2029d34584edd0f865f23db61d23">list_sort</a>(&amp;people_dl, compare_age)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Doubly-linked list sorted by age\n&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="list_example_advanced"></a>
Advanced: Remove Duplicates and Reverse</h2>
<div class="fragment"><div class="line"><span class="comment">// Remove consecutive duplicates after sorting</span></div>
<div class="line"><span class="keywordtype">bool</span> are_equal(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *a, <span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *b) {</div>
<div class="line">    <span class="keyword">const</span> person_t *pa = (<span class="keyword">const</span> person_t *)a;</div>
<div class="line">    <span class="keyword">const</span> person_t *pb = (<span class="keyword">const</span> person_t *)b;</div>
<div class="line">    <span class="keywordflow">return</span> pa-&gt;age == pb-&gt;age;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="lists_8c.html#a1d2ef5df3acb9c143b11dedbf8f98873">flist_sort</a>(&amp;people, compare_age);</div>
<div class="line"><span class="keywordtype">size_t</span> removed = <a class="code hl_function" href="lists_8c.html#ab0fdc9ebd75e23b44aba0bdee29abc73">flist_unique</a>(&amp;people, are_equal, delete_person);</div>
<div class="line">printf(<span class="stringliteral">&quot;Removed %zu duplicates\n&quot;</span>, removed);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reverse the list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="lists_8c.html#a27afe8b13878e2178d62ab4b3f842f78">flist_reverse</a>(&amp;people)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;List reversed (now descending order)\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove all minors</span></div>
<div class="line"><span class="keywordtype">bool</span> is_minor(<span class="keyword">const</span> <a class="code hl_struct" href="structflist__node__t.html">flist_node_t</a> *node) {</div>
<div class="line">    <span class="keyword">const</span> person_t *p = (<span class="keyword">const</span> person_t *)node;</div>
<div class="line">    <span class="keywordflow">return</span> p-&gt;age &lt; 18;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> removed_minors = <a class="code hl_function" href="lists_8c.html#a325ba8b8be1eb8ccc080d3b1d5c79e8f">flist_remove_if</a>(&amp;people, is_minor, delete_person);</div>
<div class="line">printf(<span class="stringliteral">&quot;Removed %zu minors\n&quot;</span>, removed_minors);</div>
</div><!-- fragment --><h1><a class="anchor" id="list_performance"></a>
Performance Characteristics</h1>
<h2><a class="anchor" id="flist_performance"></a>
Forward List Performance</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Time Complexity   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_push_front</code>   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Constant time    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_pop_front</code>   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Constant time    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_push_back</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must traverse entire list    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_pop_back</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must find second-to-last node    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_insert_after</code>   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Constant time if reference known    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_remove</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must find previous node    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_remove_if</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Traverses list once    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_clear</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must visit all nodes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_size</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must count all nodes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_empty</code>   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Just checks if head is NULL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_sort</code>   </td><td class="markdownTableBodyNone">O(n²)   </td><td class="markdownTableBodyNone">Bubble sort implementation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flist_unique</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Single pass after sorting    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flist_reverse</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Single pass, reverses pointers   </td></tr>
</table>
<p>Memory overhead:** 4-8 bytes per node (one pointer)</p>
<h2><a class="anchor" id="list_performance"></a>
Performance Characteristics</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Time Complexity   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_push_front</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone">Constant time    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_pop_front</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone">Constant time    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_push_back</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone"><b>Direct access via prev!</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_pop_back</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone"><b>Direct access via prev!</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_insert_before</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone"><b>Direct access via prev!</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_insert_after</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone">Constant time    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_remove</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone"><b>Direct access via prev!</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_remove_if</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Traverses list once    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_clear</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must visit all nodes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_size</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Must count all nodes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_empty</code>   </td><td class="markdownTableBodyNone">O(1) ⚡   </td><td class="markdownTableBodyNone">Just checks if head is NULL    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_sort</code>   </td><td class="markdownTableBodyNone">O(n²)   </td><td class="markdownTableBodyNone">Bubble sort implementation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>list_unique</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Single pass after sorting    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>list_reverse</code>   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">Single pass, swaps pointers   </td></tr>
</table>
<p>Memory overhead:** 8-16 bytes per node (two pointers)</p>
<h2><a class="anchor" id="list_performance_comparison"></a>
Performance Comparison</h2>
<p>When to use forward lists (<code>flist</code>):**</p><ul>
<li>Memory is critical (saves 4-8 bytes per node)</li>
<li>Only need forward traversal</li>
<li>Rarely need tail operations</li>
<li><p class="startli">Example: Stack-like data structures, one-directional iteration</p>
<p class="startli">When to use doubly-linked lists (<code>list</code>):**</p>
</li>
<li>Need frequent tail operations (O(1) vs O(n) ⚡)</li>
<li>Need to insert/remove at known positions efficiently</li>
<li>Need bidirectional traversal</li>
<li>Memory overhead is acceptable</li>
<li>Example: LRU caches, undo/redo systems, navigation histories</li>
</ul>
<h1><a class="anchor" id="list_limitations"></a>
Limitations</h1>
<h2><a class="anchor" id="flist_limitations"></a>
Forward List Limitations</h2>
<ol type="1">
<li><b>No backward traversal</b>: Cannot iterate backward through the list.</li>
<li><b>No tail pointer</b>: <code>push_back</code> and <code>pop_back</code> are O(n). For frequent tail operations, use doubly-linked lists instead.</li>
<li><b>No insert_before</b>: Cannot insert before a node without traversing from head. Use doubly-linked lists for O(1) insert_before.</li>
<li><b>Bubble sort</b>: The sort implementation is O(n²). For large lists, consider using an external sorting algorithm.</li>
</ol>
<h2><a class="anchor" id="list_limitations"></a>
Limitations</h2>
<ol type="1">
<li><b>Memory overhead</b>: Uses twice the memory per node compared to forward lists (two pointers instead of one).</li>
<li><b>Bubble sort</b>: The sort implementation is O(n²). For large lists, consider using an external sorting algorithm.</li>
<li><b>No tail caching</b>: While tail operations are O(1), finding the tail initially requires traversal. For repeated tail access, cache the tail pointer in your application.</li>
</ol>
<h2><a class="anchor" id="list_common_limitations"></a>
Common Limitations (Both Types)</h2>
<ol type="1">
<li><b>No built-in search</b>: Searching requires manual traversal. Implement application-specific search functions.</li>
<li><b>No thread safety</b>: The library is not thread-safe. Implement external synchronization if needed.</li>
<li><b>No automatic memory management</b>: Applications must manage node allocation and provide deletion callbacks.</li>
</ol>
<h1><a class="anchor" id="list_alternatives"></a>
When to Use Alternatives</h1>
<p>Consider alternatives if you need:</p>
<p>Instead of forward lists (<code>flist</code>):**</p><ul>
<li><b>Frequent tail operations</b>: Use doubly-linked list (<code>list</code>) for O(1) tail access ⚡</li>
<li><b>Bidirectional traversal</b>: Use doubly-linked list (<code>list</code>)</li>
<li><p class="startli"><b>Insert before operation</b>: Use doubly-linked list (<code>list</code>) for O(1) insert_before ⚡</p>
<p class="startli">Instead of doubly-linked lists (<code>list</code>):**</p>
</li>
<li><b>Minimal memory usage</b>: Use forward list (<code>flist</code>) to save 4-8 bytes per node</li>
<li><p class="startli"><b>Simple one-directional access</b>: Use forward list (<code>flist</code>) for simplicity</p>
<p class="startli">Instead of any linked list:**</p>
</li>
<li><b>Fast random access</b>: Use array-based structures (indexing is O(1) vs O(n))</li>
<li><b>Efficient sorting of large datasets</b>: Pre-sort data before insertion or use array + qsort</li>
<li><b>Memory profiling</b>: Use <code>lib_alloc</code> for allocation tracking and debugging</li>
<li><p class="startli"><b>Fixed-size collections</b>: Use static arrays for better cache locality</p>
<p class="startli">Hybrid approaches:**</p>
</li>
<li>Maintain a separate tail pointer with forward lists for O(1) tail access</li>
<li>Use ring buffers for fixed-size FIFO/LIFO operations</li>
<li>Combine with hash tables for O(1) lookup + ordered iteration </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
