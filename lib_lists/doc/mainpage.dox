/** @page list_mainpage Generic Linked List Library

@section list_mainpage_intro Introduction

This page describes the Generic Linked List library available for Applications.

The `lib_lists` provides two types of linked list implementations:
- **Forward lists** (`flist_*`): Singly-linked lists with minimal memory overhead
- **Doubly-linked lists** (`list_*`): Bidirectional lists with previous pointers

Both implementations share a common architecture with generic node structures that can
be embedded in any data structure. This design is based on the app-ethereum implementation
and is optimized for embedded systems like Ledger devices.

@section list_node_structure Node Structures

@subsection flist_node Forward List Node (Singly-Linked)

The forward list node contains only a next pointer:

@code{.c}
typedef struct flist_node_t {
    struct flist_node_t *next;
} flist_node_t;
@endcode

**Usage:** Embed `flist_node_t` as the first member of your structure, its name is irrelevant:

@code{.c}
typedef struct my_data_s {
    flist_node_t _node;  // Must be first member
    int value;
    char name[32];
} my_data_t;

flist_node_t *my_flist = NULL;  // Empty forward list
@endcode

**Memory overhead:** 4-8 bytes per node (one pointer)

@subsection list_node Doubly-Linked List Node

The doubly-linked node contains both next and previous pointers:

@code{.c}
typedef struct list_node_t {
    flist_node_t        _list;  // Contains next pointer
    struct list_node_t *prev;   // Previous pointer
} list_node_t;
@endcode

**Usage:** Embed `list_node_t` as the first member of your structure, its name is irrelevant:

@code{.c}
typedef struct my_data_s {
    list_node_t _node;  // Must be first member
    int value;
    char name[32];
} my_data_t;

my_data_t *my_list = NULL;  // Empty doubly-linked list
@endcode

**Memory overhead:** 8-16 bytes per node (two pointers)

@subsection list_choosing Choosing Between Forward Lists and Doubly-Linked Lists

| Feature                  | Forward List (`flist`) | Doubly-Linked (`list`) |
|--------------------------|------------------------|------------------------|
| Memory per node          | 4-8 bytes              | 8-16 bytes             |
| Insert/remove at front   | O(1) ⚡                | O(1) ⚡                |
| Insert/remove at back    | O(n)                   | O(n)                   |
| Insert after node        | O(1) ⚡                | O(1) ⚡                |
| Insert before node       | Not available          | O(1) ⚡                |
| Backward traversal       | No                     | Yes                    |
| Reverse operation        | O(n)                   | O(n)                   |

**Best practice:** Use forward lists when memory is critical and you don't need backward
traversal or frequent tail operations. Use doubly-linked lists when you need bidirectional
access or O(1) tail operations.

@section list_complexity Understanding Time Complexity

The documentation uses **Big O notation** to describe algorithm performance:

- **O(1) - Constant time**: The operation takes the same time regardless of list size
  - Example: Adding to the front of the list always requires the same steps
  - Performance: Excellent for embedded systems ✓

- **O(n) - Linear time**: Time increases proportionally with the number of elements (n)
  - Example: Finding the last element requires traversing all n elements
  - Performance: Acceptable for small to medium lists

- **O(n²) - Quadratic time**: Time increases with the square of the number of elements
  - Example: Bubble sort compares elements multiple times
  - Performance: Avoid for large lists in embedded systems

**Concrete examples:**
| List Size | O(1)      | O(n)           | O(n²)              |
|-----------|-----------|----------------|--------------------|
| 10 items  | 1 step    | 10 steps       | 100 steps          |
| 100 items | 1 step    | 100 steps      | 10,000 steps       |
| 1000 items| 1 step    | 1,000 steps    | 1,000,000 steps    |

**Best practice:** Always prefer O(1) operations when possible for optimal performance.

@section list_operations Basic Operations

All operations are available for both forward lists and doubly-linked lists with similar APIs:
- Forward list functions: `flist_*`
- Doubly-linked list functions: `list_*`

@subsection list_insertion Insertion Operations

**Push Front** - Add a node at the beginning (O(1) for both types):

@code{.c}
// Forward list example
my_data_t *data = malloc(sizeof(*data));
if (data != NULL) {
    memset(data, 0, sizeof(*data));
    data->value = 42;
    flist_push_front((flist_node_t**)&my_flist, (flist_node_t*)data);
    // Successfully inserted
}

// Doubly-linked list example
my_data_t *data2 = malloc(sizeof(*data2));
if (data2 != NULL) {
    memset(data2, 0, sizeof(*data2));
    data2->value = 43;
    list_push_front((list_node_t**)&my_list, (list_node_t*)data2);
    // Successfully inserted
}
@endcode

**Push Back** - Add a node at the end, O(n) - must traverse entire list:

@code{.c}
// Forward list
flist_push_back((flist_node_t **)&my_flist, (flist_node_t*)data);

// Doubly-linked
list_push_back((list_node_t**)&my_list, (list_node_t*)data);
@endcode

**Insert After** - Insert a node after a reference node, O(1):

@code{.c}
my_data_t *new_data = malloc(sizeof(*new_data));
if (new_data != NULL) {
    memset(new_data, 0, sizeof(*new_data));
    list_insert_after((list_node_t**)&my_list, (list_node_t*)ref_node, (list_node_t*)new_data);
    // Successfully inserted after ref_node
}
@endcode

**Insert Before** - Insert a node before a reference node:
- Forward list: Not available (requires backward traversal)
- Doubly-linked: O(1) - direct access via prev pointer ⚡

@code{.c}
// Only available for doubly-linked lists
my_data_t *new_data = malloc(sizeof(*new_data));
if (new_data != NULL) {
    memset(new_data, 0, sizeof(*new_data));
    list_insert_before((list_node_t**)&my_list, (list_node_t*)ref_node, (list_node_t*)new_data);
    // Successfully inserted before ref_node
}
@endcode

@subsection list_removal Removal Operations

They accept an optional deletion callback to clean up node data.

**Pop Front** - Remove the first node (O(1) for both):

@code{.c}
void my_delete_func(my_data_t *node) {
    // Clean up data if needed
    free(node);
}

// Forward list
flist_pop_front((flist_node_t**)&my_flist, (f_list_node_del)&my_delete_func);

// Doubly-linked list
list_pop_front((list_node_t**)&my_list, (f_list_node_del)&my_delete_func);
@endcode

**Pop Back** - Remove the last node, O(n) - must find second-to-last node:

@code{.c}
// Forward list
flist_pop_back((flist_node_t**)&my_flist, (f_list_node_del)&my_delete_func);

// Doubly-linked
list_pop_back((list_node_t**)&my_list, (f_list_node_del)&my_delete_func);
@endcode

**Remove** - Remove a specific node, O(n) - must find previous node

@code{.c}
// Forward list
flist_remove((flist_node_t**)&my_flist, (flist_node_t*)node_to_remove, (f_list_node_del)&my_delete_func);

// Doubly-linked
list_remove((list_node_t**)&my_list, (list_node_t*)node_to_remove, (f_list_node_del)&my_delete_func);
@endcode

**Remove If** - Remove all nodes matching a predicate, O(n):

@code{.c}
bool is_negative(const my_data_t *node) {
    return node->value < 0;
}

// Returns the number of removed nodes
size_t removed = flist_remove_if((flist_node_t**)&my_flist, (f_list_node_pred)&is_negative, (f_list_node_del)&my_delete_func);
printf("Removed %zu negative values\n", removed);
@endcode

**Clear** - Remove all nodes, O(n):

@code{.c}
flist_clear((flist_node_t**)&my_flist, (f_list_node_del)&my_delete_func);
// All nodes were removed and list is now empty
@endcode

@subsection list_utilities Utility Operations

**Get Size** - Count the number of nodes, O(n):

@code{.c}
size_t count = flist_size((flist_node_t**)&my_flist);
size_t count2 = list_size((list_node_t**)&my_list);
@endcode

**Check Empty** - Test if list is empty, O(1):

@code{.c}
if (flist_empty((flist_node_t**)&my_flist)) {
    printf("Forward list is empty\n");
}

if (list_empty((list_node_t**)&my_list)) {
    printf("Doubly-linked list is empty\n");
}
@endcode

**Sort** - Sort the list using a comparison function, O(n²):

@code{.c}
bool my_compare_func(const my_data_t *a, const my_data_t *b) {
    return a->value <= b->value;  // true if in correct order
}

// Forward list
flist_sort((flist_node_t**)&my_flist, (f_list_node_cmp)&my_compare_func);

// Doubly-linked list
list_sort((list_node_t**)&my_list, (f_list_node_cmp)&my_compare_func);
@endcode

**Unique** - Remove consecutive duplicate nodes, O(n):

@code{.c}
bool are_equal(const my_data_t *a, const my_data_t *b) {
    return a->value == b->value;
}

// Returns the number of removed duplicates
size_t removed = flist_unique((flist_node_t**)&my_flist, (f_list_node_bin_pred)&are_equal, (f_list_node_del)&my_delete_func);
printf("Removed %zu duplicates\n", removed);
@endcode

**Reverse** - Reverse the order of nodes, O(n):

@code{.c}
flist_reverse((flist_node_t**)&my_flist);

list_reverse((list_node_t**)&my_list);
@endcode

@section list_traversal List Traversal

@subsection flist_traversal Forward List Traversal (Forward Only)

@code{.c}
// Forward iteration only
for (flist_node_t *node = my_flist; node != NULL; node = node->next) {
    my_data_t *data = (my_data_t *)node;
    printf("Value: %d\n", data->value);
}
@endcode

@subsection list_traversal Doubly-Linked List Traversal (Both Directions)

@code{.c}
// Forward iteration
for (list_node_t *node = my_list; node != NULL; node = (list_node_t *)((flist_node_t*)node)->next) {
    my_data_t *data = (my_data_t *)node;
    printf("Value: %d\n", data->value);
}

// Backward iteration - only possible with doubly-linked lists!
list_node_t *tail = my_list;
if (tail != NULL) {
    // Find the tail
    while (((flist_node_t*)tail)->next != NULL) {
        tail = (list_node_t *)((flist_node_t*)tail)->next;
    }
    // Traverse backward
    for (list_node_t *node = tail; node != NULL; node = node->prev) {
        my_data_t *data = (my_data_t *)node;
        printf("Value: %d\n", data->value);
    }
}
@endcode

@section list_safety Safety and Error Handling

The library implements several safety checks:

1. **NULL pointer checks**: All functions validate their parameters
2. **Node state validation**:
   - Forward list: Insertion functions correctly initialize and update `node->next` to link the node into the list (for example, to the current head for `push_front`, or to `NULL` when inserting at the end)
   - Doubly-linked: Insertion functions correctly initialize and update both `node->next` and `node->prev` to link the node between its neighbors in the list
   - This consistent pointer management prevents:
     - Creating cycles in the list
     - Accidentally linking nodes from different lists
     - Losing track of existing node chains

3. **Counter operations**: `remove_if`, `unique`, and `size` return `size_t` with count information

@section list_best_practices Best Practices

1. **Always initialize nodes** before insertion:
   @code{.c}
   // Forward list
   my_data_t *data = malloc(sizeof(*data));
   if (data != NULL) {
       memset(data, 0, sizeof(*data));
       // insertion
   }

   // Doubly-linked list
   my_data_t *data2 = malloc(sizeof(*data2));
   if (data2 != NULL) {
       memset(data2, 0, sizeof(*data2));
       // insertion
   }
   @endcode

2. **Use the deletion callback** to prevent memory leaks:
   @code{.c}
   flist_clear((flist_node_t**)&my_flist, (f_list_node_del)&my_delete_func);
   @endcode

3. **Choose the right list type:**
   - Use `flist` (forward list) for minimal memory usage
   - Use `list` (doubly-linked) for bidirectional access

4. **Prefer front operations** when order doesn't matter:
   - `flist_push_front` is O(1)
   - `list_push_front` is O(1)
   - Both are faster than push_back for forward lists

5. **Don't reuse nodes** across multiple lists without proper unlinking

@section list_examples Complete Examples

@subsection list_example_basic Forward List Basic Usage

@code{.c}
#include "lists.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef struct person_s {
    flist_node_t _node;
    char name[32];
    int age;
} person_t;

void delete_person(person_t *person) {
    printf("Deleting: %s\n", person->name);
    free(person);
}

int main(void) {
    person_t *people = NULL;

    // Add some people
    person_t *alice = malloc(sizeof(*alice));
    if (alice != NULL) {
        memset(alice, 0, sizeof(*alice));
        strcpy(alice->name, "Alice");
        alice->age = 30;
        flist_push_front((flist_node_t**)&people, (flist_node_t*)alice);
    }

    person_t *bob = malloc(sizeof(*bob));
    if (bob != NULL) {
        memset(bob, 0, sizeof(*bob));
        strcpy(bob->name, "Bob");
        bob->age = 25;
        flist_push_back((flist_node_t**)&people, (flist_node_t*)bob);
    }

    // Print all people
    for (flist_node_t *node = (flist_node_t*)people; node != NULL; node = node->next) {
        person_t *p = (person_t *)node;
        printf("%s is %d years old\n", p->name, p->age);
    }

    // Clean up
    flist_clear((flist_node_t**)&people, (f_list_node_del)&delete_person);

    return 0;
}
@endcode

@subsection list_example_doubly Doubly-Linked List with Backward Traversal

@code{.c}
#include "lists.h"
#include <stdlib.h>
#include <stdio.h>

typedef struct person_s {
    list_node_t _node;
    char name[32];
    int age;
} person_t;

void delete_person_dl(person_t *person) {
    printf("Deleting: %s\n", person->name);
    free(person);
}

int main(void) {
    person_t *people = NULL;

    // Add people
    person_t *alice = malloc(sizeof(*alice));
    if (alice != NULL) {
        memset(alice, 0, sizeof(*alice));
        strcpy(alice->name, "Alice");
        alice->age = 30;
        list_push_back((list_node_t**)&people, (list_node_t*)alice);
    }

    person_t *bob = malloc(sizeof(*bob));
    if (bob != NULL) {
        memset(bob, 0, sizeof(*bob));
        strcpy(bob->name, "Bob");
        bob->age = 25;
        list_push_back((list_node_t**)&people, (list_node_t*)bob);
    }

    // Forward traversal
    printf("Forward:\n");
    for (flist_node_t *node = (flist_node_t*)people; node != NULL; node = node->next) {
        person_t *p = (person_t *)node;
        printf("  %s is %d years old\n", p->name, p->age);
    }

    // Backward traversal - only possible with doubly-linked!
    printf("Backward:\n");
    flist_node_t *tail = (flist_node_t*)people;
    while (tail && tail->next) {
        tail = tail->next;
    }
    for (list_node_t *node = (list_node_t*)tail; node != NULL; node = node->prev) {
        person_t *p = (person_t *)node;
        printf("  %s is %d years old\n", p->name, p->age);
    }

    // Clean up
    list_clear((list_node_t**)&people, (f_list_node_del)&delete_person_dl);

    return 0;
}
@endcode

@subsection list_example_sort Sorting Example

@code{.c}
bool compare_age(const person_t *a, const person_t *b) {
    return a->age <= b->age;  // Sort by age ascending
}

// Sort forward list
flist_sort((flist_node_t**)&people, (f_list_node_cmp)&compare_age);

// Sort doubly-linked list
list_sort((list_node_t**)&people_dl, (f_list_node_cmp)&compare_age);
@endcode

@subsection list_example_advanced Advanced: Remove Duplicates and Reverse

@code{.c}
// Remove consecutive duplicates after sorting
bool are_equal(const person_t *a, const person_t *b) {
    return a->age == b->age;
}

flist_sort((flist_node_t**)&people, (f_list_node_cmp)&compare_age);
size_t removed = flist_unique((flist_node_t**)&people, (f_list_node_bin_pred)&are_equal, (f_list_node_del)&delete_person);
printf("Removed %zu duplicates\n", removed);

// Reverse the list
flist_reverse((flist_node_t**)&people);
printf("List reversed (now descending order)\n");

// Remove all minors
bool is_minor(const person_t *p) {
    return p->age < 18;
}

size_t removed_minors = flist_remove_if((flist_node_t**)&people, (f_list_node_pred)&is_minor, (f_list_node_del)&delete_person);
printf("Removed %zu minors\n", removed_minors);
@endcode

@section list_performance Performance Characteristics

@subsection flist_performance Forward List Performance

| Operation               | Time Complexity | Notes                            |
|-------------------------|-----------------|----------------------------------|
| `flist_push_front`      | O(1) ⚡         | Constant time                    |
| `flist_pop_front`       | O(1) ⚡         | Constant time                    |
| `flist_push_back`       | O(n)            | Must traverse entire list        |
| `flist_pop_back`        | O(n)            | Must find second-to-last node    |
| `flist_insert_after`    | O(1) ⚡         | Constant time if reference known |
| `flist_remove`          | O(n)            | Must find previous node          |
| `flist_remove_if`       | O(n)            | Traverses list once              |
| `flist_clear`           | O(n)            | Must visit all nodes             |
| `flist_size`            | O(n)            | Must count all nodes             |
| `flist_empty`           | O(1) ⚡         | Just checks if head is NULL      |
| `flist_sort`            | O(n²)           | Bubble sort implementation       |
| `flist_unique`          | O(n)            | Single pass after sorting        |
| `flist_reverse`         | O(n)            | Single pass, reverses pointers   |

**Memory overhead:** 4-8 bytes per node (one pointer)

@subsection list_performance Doubly-Linked List Performance

| Operation               | Time Complexity | Notes                            |
|-------------------------|-----------------|----------------------------------|
| `list_push_front`       | O(1) ⚡         | Constant time                    |
| `list_pop_front`        | O(1) ⚡         | Constant time                    |
| `list_push_back`        | O(n)            | Must traverse entire list        |
| `list_pop_back`         | O(n)            | Must find second-to-last node    |
| `list_insert_before`    | O(1) ⚡         | **Direct access via prev!**      |
| `list_insert_after`     | O(1) ⚡         | Constant time                    |
| `list_remove`           | O(n)            | Must find previous node          |
| `list_remove_if`        | O(n)            | Traverses list once              |
| `list_clear`            | O(n)            | Must visit all nodes             |
| `list_size`             | O(n)            | Must count all nodes             |
| `list_empty`            | O(1) ⚡         | Just checks if head is NULL      |
| `list_sort`             | O(n²)           | Bubble sort implementation       |
| `list_unique`           | O(n)            | Single pass after sorting        |
| `list_reverse`          | O(n)            | Single pass, swaps pointers      |

**Memory overhead:** 8-16 bytes per node (two pointers)

@subsection list_performance_comparison Performance Comparison

**When to use forward lists (`flist`):**
- Memory is critical (saves 4-8 bytes per node)
- Only need forward traversal
- Rarely need tail operations
- Example: Stack-like data structures, one-directional iteration

**When to use doubly-linked lists (`list`):**
- Need bidirectional traversal
- Memory overhead is acceptable
- Example: LRU caches, undo/redo systems, navigation histories

@section list_limitations Limitations

@subsection flist_limitations Forward List Limitations

1. **No backward traversal**: Cannot iterate backward through the list.

2. **No insert_before**: Cannot insert before a node without traversing from head.
   Use doubly-linked lists for O(1) insert_before.

3. **Bubble sort**: The sort implementation is O(n²). For large lists, consider using
   an external sorting algorithm.

@subsection list_limitations Doubly-Linked List Limitations

1. **Memory overhead**: Uses twice the memory overhead per node compared to forward lists
   (two pointers instead of one).

2. **Bubble sort**: The sort implementation is O(n²). For large lists, consider using
   an external sorting algorithm.

@subsection list_common_limitations Common Limitations (Both Types)

1. **No built-in search**: Searching requires manual traversal. Implement application-specific
   search functions.

2. **No thread safety**: The library is not thread-safe. Implement external synchronization
   if needed.

3. **No automatic memory management**: Applications must manage node allocation and provide
   deletion callbacks.

4. **No tail pointer**: `push_back` and `pop_back` are O(n).

@section list_alternatives When to Use Alternatives

Consider alternatives if you need:

**Instead of forward lists (`flist`):**
- **Bidirectional traversal**: Use doubly-linked list (`list`)
- **Insert before operation**: Use doubly-linked list (`list`) for O(1) insert_before ⚡

**Instead of doubly-linked lists (`list`):**
- **Minimal memory usage**: Use forward list (`flist`) to save 4-8 bytes per node
- **Simple one-directional access**: Use forward list (`flist`) for simplicity

**Instead of any linked list:**
- **Fast random access**: Use array-based structures (indexing is O(1) vs O(n))
- **Efficient sorting of large datasets**: Pre-sort data before insertion or use array + qsort
- **Memory profiling**: Use `lib_alloc` for allocation tracking and debugging
- **Fixed-size collections**: Use static arrays for better cache locality

**Hybrid approaches:**
- Maintain a separate tail pointer with forward lists for O(1) tail access
- Use ring buffers for fixed-size FIFO/LIFO operations
- Combine with hash tables for O(1) lookup + ordered iteration

*/
