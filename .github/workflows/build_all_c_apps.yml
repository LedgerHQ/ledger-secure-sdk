name: Build all C apps on latest C SDK

on:
  workflow_dispatch:
    inputs:
      sdk_branch:
        type: string
        required: false
        default: ''
  pull_request:

# NOTE : changes made to this file in the context of  this PR will be reverted
#        these are just for the sake of testing the PR

jobs:
  build-docker:
    name: Build ledger-app-builder-lite
    uses: LedgerHQ/ledger-app-workflows/.github/workflows/reusable_docker_deployment.yml@v1
    with:
      app_repository: LedgerHQ/ledger-app-builder
      app_ref: mbr/clang-21
      image_name: ledger-app-builder-lite
      dockerfile_path: lite/Dockerfile
      dry_run: true
      outputs: "type=docker,dest=/tmp/ledger-app-builder-lite.tar"
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}

  build-docker-full:
    name: Build ledger-app-builder
    needs: [build-docker]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ledger-app-builder
        uses: actions/checkout@v4
        with:
          repository: LedgerHQ/ledger-app-builder
          ref: mbr/clang-21
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download ledger-app-builder-lite image artifact
        uses: actions/download-artifact@v4
        with:
          name: ledger-app-builder-lite
          path: /tmp

      - name: Load ledger-app-builder-lite image
        run: docker load -i /tmp/ledger-app-builder-lite.tar

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker

      - name: Build ledger-app-builder image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: full/Dockerfile
          push: false
          tags: ledger-app-builder:latest
          outputs: type=docker,dest=/tmp/ledger-app-builder.tar

      - name: Upload ledger-app-builder image artifact
        uses: actions/upload-artifact@v4
        with:
          name: ledger-app-builder
          path: /tmp/ledger-app-builder.tar
          retention-days: 1

  prepare-matrix:
    name: Retrieve C apps
    runs-on: ubuntu-latest
    outputs:
      c_apps: ${{ steps.get_c_apps.outputs.c_apps }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
            python-version: '3.x'
      - name: Install ledgered
        run: pip install ledgered
      - name: Get all C apps
        id: get_c_apps
        run: |
          python .github/workflows/scripts/get_c_apps.py ${{ secrets.GITHUB_TOKEN }}
          echo "c_apps=$(cat c_apps.json)" >> $GITHUB_OUTPUT

  print-matrix:
    needs: [prepare-matrix]
    runs-on: ubuntu-latest
    steps:
      - name: Print matrix
        run: |
          echo "Matrix content: ${{ needs.prepare-matrix.outputs.c_apps }}"

  test-build:
    name: Build for all targets
    needs: [prepare-matrix, build-docker-full]
    strategy:
      fail-fast: false
      matrix:
        apps: ${{ fromJSON(needs.prepare-matrix.outputs.c_apps) }}
    runs-on: ubuntu-latest

    steps:
      - name: Clone App
        uses: actions/checkout@v4
        with:
          repository: LedgerHQ/${{ matrix.apps.app-name }}
          submodules: recursive
          path: ${{ matrix.apps.app-name }}
      - name: Clone SDK
        uses: actions/checkout@v4
        with:
          path: sdk
          ref: ${{ inputs.sdk_branch }}

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: ledger-app-builder
          path: /tmp

      - name: Load Docker image and start build container
        run: |
          LOADED_IMAGE=$(docker load -i /tmp/ledger-app-builder.tar | grep "Loaded image" | head -1 | awk '{print $NF}')
          docker run -d --name builder -v $GITHUB_WORKSPACE:/workspace "$LOADED_IMAGE" sleep infinity
          docker exec builder pip install --break-system-packages ledgered

      - name: Create artifacts directory
        run: mkdir -p $GITHUB_WORKSPACE/artifacts

      - name: Build App for Nano X
        if: contains(matrix.apps.devices, 'nanox')
        continue-on-error: true
        run: |
          docker exec builder bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Nano X' &&
            make clean &&
            make TARGET=nanox BOLOS_SDK=/workspace/sdk
          "
      - name: Collect Nano X binary
        if: contains(matrix.apps.devices, 'nanox')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanox/bin/app.elf \
             artifacts/${{ matrix.apps.app-name }}-nanox.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanox/dbg/app.map \
             artifacts/${{ matrix.apps.app-name }}-nanox.map || true
      - name: Build App for Nano S+
        if: contains(matrix.apps.devices, 'nanos+')
        continue-on-error: true
        run: |
          docker exec builder bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Nano S+' &&
            make clean &&
            make TARGET=nanos2 BOLOS_SDK=/workspace/sdk
          "
      - name: Collect Nano S+ binary
        if: contains(matrix.apps.devices, 'nanos+')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanos2/bin/app.elf \
             artifacts/${{ matrix.apps.app-name }}-nanosp.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanos2/dbg/app.map \
             artifacts/${{ matrix.apps.app-name }}-nanosp.map || true
      - name: Build App for Stax
        if: contains(matrix.apps.devices, 'stax')
        continue-on-error: true
        run: |
          docker exec builder bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Stax' &&
            make clean &&
            make TARGET=stax BOLOS_SDK=/workspace/sdk
          "
      - name: Collect Stax binary
        if: contains(matrix.apps.devices, 'stax')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/stax/bin/app.elf \
             artifacts/${{ matrix.apps.app-name }}-stax.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/stax/dbg/app.map \
             artifacts/${{ matrix.apps.app-name }}-stax.map || true
      - name: Build App for Flex
        if: contains(matrix.apps.devices, 'flex')
        continue-on-error: true
        run: |
          docker exec builder bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Flex' &&
            make clean &&
            make TARGET=flex BOLOS_SDK=/workspace/sdk
          "
      - name: Collect Flex binary
        if: contains(matrix.apps.devices, 'flex')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/flex/bin/app.elf \
             artifacts/${{ matrix.apps.app-name }}-flex.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/flex/dbg/app.map \
             artifacts/${{ matrix.apps.app-name }}-flex.map || true
      - name: Build App for Apex+
        if: contains(matrix.apps.devices, 'apex_p')
        continue-on-error: true
        run: |
          docker exec builder bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Apex+' &&
            make clean &&
            make TARGET=apex_p BOLOS_SDK=/workspace/sdk
          "
      - name: Collect Apex+ binary
        if: contains(matrix.apps.devices, 'apex_p')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/apex_p/bin/app.elf \
             artifacts/${{ matrix.apps.app-name }}-apex_p.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/apex_p/dbg/app.map \
             artifacts/${{ matrix.apps.app-name }}-apex_p.map || true

      - name: Upload app binaries
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.apps.app-name }}-binaries
          path: artifacts/
          if-no-files-found: ignore
          retention-days: 1

      - name: Cleanup
        if: always()
        run: docker rm -f builder || true

  test-build-official:
    name: Build for all targets (official image)
    needs: [prepare-matrix]
    strategy:
      fail-fast: false
      matrix:
        apps: ${{ fromJSON(needs.prepare-matrix.outputs.c_apps) }}
    runs-on: ubuntu-latest

    steps:
      - name: Clone App
        uses: actions/checkout@v4
        with:
          repository: LedgerHQ/${{ matrix.apps.app-name }}
          submodules: recursive
          path: ${{ matrix.apps.app-name }}

      - name: Pull official Docker image and start build container
        run: |
          docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder:5.0.2
          docker run -d --name builder-official -v $GITHUB_WORKSPACE:/workspace ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder:5.0.2 sleep infinity
          docker exec builder-official pip install --break-system-packages ledgered

      - name: Create artifacts directory
        run: mkdir -p $GITHUB_WORKSPACE/artifacts-official

      - name: Build App for Nano X
        if: contains(matrix.apps.devices, 'nanox')
        continue-on-error: true
        run: |
          docker exec builder-official bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Nano X' &&
            make clean &&
            make TARGET=nanox BOLOS_SDK=/opt/nanox-secure-sdk
          "
      - name: Collect Nano X binary
        if: contains(matrix.apps.devices, 'nanox')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanox/bin/app.elf \
             artifacts-official/${{ matrix.apps.app-name }}-nanox.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanox/dbg/app.map \
             artifacts-official/${{ matrix.apps.app-name }}-nanox.map || true
      - name: Build App for Nano S+
        if: contains(matrix.apps.devices, 'nanos+')
        continue-on-error: true
        run: |
          docker exec builder-official bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Nano S+' &&
            make clean &&
            make TARGET=nanos2 BOLOS_SDK=/opt/nanosplus-secure-sdk
          "
      - name: Collect Nano S+ binary
        if: contains(matrix.apps.devices, 'nanos+')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanos2/bin/app.elf \
             artifacts-official/${{ matrix.apps.app-name }}-nanosp.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/nanos2/dbg/app.map \
             artifacts-official/${{ matrix.apps.app-name }}-nanosp.map || true
      - name: Build App for Stax
        if: contains(matrix.apps.devices, 'stax')
        continue-on-error: true
        run: |
          docker exec builder-official bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Stax' &&
            make clean &&
            make TARGET=stax BOLOS_SDK=/opt/stax-secure-sdk
          "
      - name: Collect Stax binary
        if: contains(matrix.apps.devices, 'stax')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/stax/bin/app.elf \
             artifacts-official/${{ matrix.apps.app-name }}-stax.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/stax/dbg/app.map \
             artifacts-official/${{ matrix.apps.app-name }}-stax.map || true
      - name: Build App for Flex
        if: contains(matrix.apps.devices, 'flex')
        continue-on-error: true
        run: |
          docker exec builder-official bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Flex' &&
            make clean &&
            make TARGET=flex BOLOS_SDK=/opt/flex-secure-sdk
          "
      - name: Collect Flex binary
        if: contains(matrix.apps.devices, 'flex')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/flex/bin/app.elf \
             artifacts-official/${{ matrix.apps.app-name }}-flex.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/flex/dbg/app.map \
             artifacts-official/${{ matrix.apps.app-name }}-flex.map || true
      - name: Build App for Apex+
        if: contains(matrix.apps.devices, 'apex_p')
        continue-on-error: true
        run: |
          docker exec builder-official bash -c "
            cd /workspace/${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }} &&
            echo 'Building for Apex+' &&
            make clean &&
            make TARGET=apex_p BOLOS_SDK=/opt/apex-secure-sdk
          "
      - name: Collect Apex+ binary
        if: contains(matrix.apps.devices, 'apex_p')
        run: |
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/apex_p/bin/app.elf \
             artifacts-official/${{ matrix.apps.app-name }}-apex_p.elf || true
          cp ${{ matrix.apps.app-name }}/${{ matrix.apps.build-directory }}/build/apex_p/dbg/app.map \
             artifacts-official/${{ matrix.apps.app-name }}-apex_p.map || true

      - name: Upload app binaries
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.apps.app-name }}-binaries-official
          path: artifacts-official/
          if-no-files-found: ignore
          retention-days: 1

      - name: Cleanup
        if: always()
        run: docker rm -f builder-official || true

  compare-builds:
    name: Compare builds
    needs: [prepare-matrix, test-build, test-build-official]
    if: always()
    strategy:
      fail-fast: false
      matrix:
        apps: ${{ fromJSON(needs.prepare-matrix.outputs.c_apps) }}
    runs-on: ubuntu-latest

    steps:
      - name: Download custom build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.apps.app-name }}-binaries
          path: custom/
        continue-on-error: true

      - name: Download official build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.apps.app-name }}-binaries-official
          path: official/
        continue-on-error: true

      - name: Install analysis tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y binutils-arm-none-eabi

      - name: Generate comparison reports
        run: |
          cat << 'PYEOF' > compare.py
          import re, os, subprocess
          from pathlib import Path
          from collections import defaultdict
          from datetime import datetime, timezone

          DEVICES = [
              ('nanox',  'Nano X'),
              ('nanosp', 'Nano S+'),
              ('stax',   'Stax'),
              ('flex',   'Flex'),
              ('apex_p', 'Apex+'),
          ]
          SECTIONS = ['.text', '.rodata', '.data', '.bss']
          APP = os.environ['APP_NAME']
          SUMMARY = os.environ.get('GITHUB_STEP_SUMMARY', '/dev/stdout')

          def elf_sections(elf):
              """Returns {section: size} from arm-none-eabi-size -A (real ELF sizes, incl. padding)."""
              try:
                  out = subprocess.check_output(['arm-none-eabi-size', '-A', str(elf)],
                                                stderr=subprocess.DEVNULL, text=True)
              except Exception:
                  return {}
              result = {}
              for line in out.splitlines():
                  m = re.match(r'^(\.\w[\w.]*)\s+(\d+)', line)
                  if m:
                      result[m.group(1)] = int(m.group(2))
              return result

          def parse_map(path):
              """Returns {section: {obj: size}} — object-level breakdown from GNU ld map."""
              result = defaultdict(lambda: defaultdict(int))
              current_section = None
              with open(path) as f:
                  for line in f:
                      m = re.match(r'^(\.\w[\w.]*)\s+0x[0-9a-f]+\s+0x([0-9a-f]+)\s*$', line.strip(), re.I)
                      if m:
                          current_section = m.group(1)
                          continue
                      m = re.match(r'^\s+(\.\w[\w.]*)\s+0x[0-9a-f]+\s+0x([0-9a-f]+)\s+(\S+)', line, re.I)
                      if m and current_section and m.group(1) == current_section:
                          result[current_section][m.group(3)] += int(m.group(2), 16)
              return result

          def fmt_delta(d, ref):
              sign = '+' if d >= 0 else ''
              pct = f' ({sign}{d/ref*100:.1f}%)' if ref else ''
              return f'{sign}{d}{pct}'

          os.makedirs('map-reports', exist_ok=True)

          with open(SUMMARY, 'a') as summary:
              summary.write(f'# Binary comparison: {APP}\n\n')
              summary.write('Comparing **clang-14 (official)** vs **clang-21 (custom)**\n\n')
              summary.write('> Sizes from ELF section headers (include alignment padding).\n')
              summary.write('> Per-object breakdown available in the downloadable report.\n\n')

              for dev_key, dev_name in DEVICES:
                  old_elf = Path(f'official/{APP}-{dev_key}.elf')
                  new_elf = Path(f'custom/{APP}-{dev_key}.elf')
                  old_map = Path(f'official/{APP}-{dev_key}.map')
                  new_map = Path(f'custom/{APP}-{dev_key}.map')

                  has_elf  = old_elf.exists() and new_elf.exists()
                  has_map  = old_map.exists() and new_map.exists()
                  if not has_elf and not has_map:
                      continue

                  # ── ELF-based sizes ──────────────────────────────────────────
                  old_sz = elf_sections(old_elf) if has_elf else {}
                  new_sz = elf_sections(new_elf) if has_elf else {}

                  # ── Map-based per-object breakdown ───────────────────────────
                  old_map_data = parse_map(old_map) if has_map else {}
                  new_map_data = parse_map(new_map) if has_map else {}

                  # ── Job summary (ELF sizes) ──────────────────────────────────
                  summary.write(f'## {dev_name}\n\n')
                  if has_elf:
                      summary.write('| Section | clang-14 | clang-21 | Delta |\n')
                      summary.write('|---------|----------|----------|-------|\n')
                      for sec in SECTIONS:
                          o = old_sz.get(sec, 0)
                          n = new_sz.get(sec, 0)
                          summary.write(f'| `{sec}` | {o} | {n} | {fmt_delta(n-o, o)} |\n')
                      summary.write('\n')
                  else:
                      summary.write('_ELF not available for this device._\n\n')

                  # ── Downloadable report ──────────────────────────────────────
                  if not has_map:
                      continue
                  report_path = Path(f'map-reports/{APP}-{dev_key}.md')
                  with open(report_path, 'w') as rep:
                      ts = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')
                      rep.write(f'# Comparison: {APP} — {dev_name}\n\n')
                      rep.write(f'**Baseline:** clang-14 (official image)  \n')
                      rep.write(f'**New build:** clang-21 (custom image)  \n')
                      rep.write(f'**Generated:** {ts}\n\n')

                      # Section summary from ELF (real sizes)
                      if has_elf:
                          rep.write('## Section summary (ELF — incl. alignment padding)\n\n')
                          rep.write('| Section | clang-14 | clang-21 | Delta |\n')
                          rep.write('|---------|----------|----------|-------|\n')
                          for sec in SECTIONS:
                              o = old_sz.get(sec, 0)
                              n = new_sz.get(sec, 0)
                              rep.write(f'| `{sec}` | {o} | {n} | {fmt_delta(n-o, o)} |\n')
                          rep.write('\n')

                      # Per-object breakdown from map
                      for sec in SECTIONS:
                          all_objs = set(old_map_data[sec]) | set(new_map_data[sec])
                          rows = sorted(
                              [{'obj': obj,
                                'old': old_map_data[sec].get(obj, 0),
                                'new': new_map_data[sec].get(obj, 0),
                                'd':   new_map_data[sec].get(obj, 0) - old_map_data[sec].get(obj, 0)}
                               for obj in all_objs
                               if new_map_data[sec].get(obj, 0) - old_map_data[sec].get(obj, 0) != 0],
                              key=lambda x: abs(x['d']), reverse=True
                          )
                          if not rows:
                              continue
                          rep.write(f'## `{sec}` — variations by object (map)\n\n')
                          rep.write('| Object | clang-14 | clang-21 | Delta |\n')
                          rep.write('|--------|----------|----------|-------|\n')
                          for r in rows:
                              rep.write(f"| `{Path(r['obj']).name}` | {r['old']} | {r['new']} | {fmt_delta(r['d'], r['old'])} |\n")
                          rep.write('\n')

                  print(f'Generated: {report_path}')
          PYEOF
          python3 compare.py
        env:
          APP_NAME: ${{ matrix.apps.app-name }}

      - name: Upload map comparison reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.apps.app-name }}-map-reports
          path: map-reports/
          if-no-files-found: ignore
          retention-days: 7
